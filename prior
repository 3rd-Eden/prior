#!/usr/bin/env node

'use strict';

var env = process.env
  , async = require('async')
  , kuler = require('kuler')
  , prompt = require('prompt')
  , argv = require('argh').argv 
  , GitHulk = require('githulk')
  , Registry = require('npm-registry')
  , who = require('shelljs').exec('npm whoami', { silent: true }).output.trim();

//
// Prompt for the information that was not supplied using cli flags, this is
// required information and needed to continue with the spidering of data.
//
prompt.override = argv;
prompt.start();

//
// Get some sane defaults that we can spider from the user's system
//
prompt.get([
  { name: 'npm', default: who },
  { name: 'github', default: who },
  { name: 'token', default: env.GITHULK_TOKEN || env.GITHULK || env.GITHUB_TOKEN  },
  { name: 'registry', default: Registry.mirrors.nodejitsu }
], function received(err, details) {
  if (err) throw err;
  
  var npm = new Registry({ registry: details.registry })
    , github = new GitHulk({ token: details.token });

  async.parallel({
    npm: function download(next) {
      npm.users.list(details.npm, function list(err, packages) {
        if (err) return next(err);

        async.map(packages, function map(data, next) {
          npm.packages.get(data.name, function (err, data) {
            if (err) return next(err);

            //
            // The npm module returns arrays by default, we just want only item.
            //
            next(err, data[0]);
          });
        }, next);
      });
    },

    github: function download(next) {
      github.organizations.list(function err(err, orgs) {
        if (err) return next(err);

        //
        // Mark as organization so we can add it repo's that we need to check.
        //
        orgs = orgs.map(function map(org) {
          org.organization = true;
          return org;
        });

        //
        // Add our username in to the list of organizations that we need to
        // spider.
        //
        orgs.push({ login: details.github });

        async.map(orgs, function map(data, next) {
          github.repository.list(data.login, { 
            organization: data.organization 
          }, next);
        }, function failed(err, listoflists) {
          if (err) return next(err);

          var list = [];

          listoflists.forEach(function each(repos) {
            Array.prototype.push.apply(list, repos);
          });
          
          async.map(list, function map(repo) {
            repo.npm = {};

            github.repository.contents(repo.fullname, { 
              path: 'package.json'
            }, function (err, data) {
              if (err || !data || !data.length) return next(undefined, repo);

              //
              // Parse the contents of repository to see if we can find
              // a package.json so we will have something easier to match
              // against.
              //
              try { 
                data = JSON.parse((new Buffer(data[0].contents, data[0].encoding)).toString('utf-8')); 
              } catch (e) { return next(undefined, repo); }

              repo.json = data;
              next(undefined, repo);
            });
          }, name);
        });
      });
    }
  }, function downloaded(err, data) {
    if (err) throw err;

    //
    // Reduce the amount of data that we received from GitHub so we only got the
    // bare minimum of information that we need.
    //
    data.github = data.github.map(function map(repo) {
      return {
        description: repo.description,      // Fallback for npm description.
        url: repo.html_url,                 // For matching with npm modules.
        fork: repo.fork,                    // Might want to exclude forks, not OC.
        name: repo.name,                    // Name of module
        created: new Date(repo.created_at), // Created at.
        json: repo.npm,                     // Reference to package.json in repo.
        author: repo.owner.name             // Possible name of the author.
      };
    });

    //
    // Reduce the amount of data from npm to only contain the useful
    // information, this should somewhat mirror the data available from git for
    // matching.
    //
    data.npm = data.npm.map(function map(pkg) {
      return {
        description: pkg.description,     // Description of the module
        url: (pkg.repository || {}).url,  // Possible repository URL.
        fork: false,                      // Sorry, we don't understand forks.
        name: pkg.name,                   // Name of the module.
        created: new Date(pkg.created),   // Creation date.
        author: (pkg.author || {}).name   // Name of the author.
      };
    });

    //
    // Now for the tricky part, merging and matching the data.
    //
  });
});
